<!DOCTYPE html>
<html lang="en-us">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Exploring ARM inline assembly in Rust | embed.rs</title>
<link rel="stylesheet" href="https://mbr.github.io/embed.rs/css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://mbr.github.io/embed.rs"><h1 class="title is-4">embed.rs</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">October 10, 2016</h2>
    <h1 class="title">Exploring ARM inline assembly in Rust</h1>
    <div class="content">
      

<p>Inline assembly in modern languages is easily forgotten in day-to-day programming; its use has been diminished by having excellent compilers that produce equivalent or better code than what most programmers can hand-optimize. Outside of the field of optimization there are still some legitimate reasons to write a couple of instructions of assembly even then: Accessing CPU features that are platform-specific or simply not covered by compiler or library vendors.</p>

<p>This article gives a short introduction into inline assembly in Rust. It focuses on embedded development, more specifically the <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> architecture, which has a good reputation for being clear and also a lot of application in the embedded world, where one is much more likely to find oneself reaching for an assembler than on the desktop world of <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>.</p>

<h1 id="what-is-assembly">What is assembly?</h1>

<p>Compiling a valid Rust program ultimately yields a binary than can be executed. The process of generating one includes multiple steps that are hidden from the programmer:</p>

<p><img src="/post/arm-inline-assembly-rust_01.svg" alt="Rust source to machine code. See https://blog.rust-lang.org/2016/04/19/MIR.html for more details" /></p>

<p>The red section happens inside the Rust compiler which turns Rust source code into <a href="http://llvm.org/">LLVM</a> <em>intermediate representation</em> (IR). The LLVM IR can be thought of as language-agnostic; C-code compiled with <a href="http://clang.llvm.org/">clang</a> will end up as LLVM IR the same way as Rust code does at one point during compilation. After generation, the intermediate representation will be optimized and turned into the machine code that ends up inside the final binary.</p>

<p>Binary or numerical machine code refers to a set of instructions the target CPU can directly execute, with each instruction being coded numerically; e.g. adding two operands in ARM assembly is represented by the <a href="https://en.wikipedia.org/wiki/Opcode">opcode</a> <code>0100</code>. Since these are hard to read, a text-based representation is avaiablable: <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly code</a>. Addition becomes <code>ADD</code> instead of
<code>0100</code> and operands can be specified a little easier as well. Some platform-dependant exceptions aside, assembly code maps onto binary machine instructions in a 1:1 manner.</p>

<p>Modern, high-level languages exist primarily to free the programmer from having to hand-write (and optimize) assembly code for their machine. Since gaining direct access to assembly instructions is rarely worth losing the ability to write high-level code, <strong><a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembly</a></strong> can be used to write small fragments of assembly embedded in the language of choice.</p>

<h2 id="syntax">Syntax</h2>

<p>The different (human-readable) assembly syntaxes can cause a lot of confusion, as they change not only the manner in which different values are written but also the order in which operands are given. When writing x86 assembly, there are two widely used variations of assembly syntax available: <a href="http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm">Intel and AT&amp;T</a>. Given the task of writing the value <code>0x1F</code> (31 in decimal) into the <code>eax</code> register, a programmer would have to write</p>

<pre><code class="language-x86asm">mov    eax, 1fh
</code></pre>

<p>in Intel syntax and</p>

<pre><code class="language-attasm">movl   %eax, $0x1f
</code></pre>

<p>in AT&amp;T syntax.</p>

<p>Of note is that not only are the instructions named slightly different &mdash;
<code>mov</code> vs <code>movl</code> &mdash; but values prefixed in AT&amp;T. Even specifying hexadecimal numbers works different between these two. To complete the confusion, argument order is reversed as well: The destination (<code>eax</code>) is specified first in Intel syntax while being last in AT&amp;T syntax.</p>

<p>Fortunately in this article we will not have to chose either one. ARM assembly usually uses a syntax different from both of these and manages to be more readable:</p>

<pre><code class="language-armasm">mov    r0, #0x1f
</code></pre>

<p>General purpose registers in ARM assembly are named <code>r0</code> through <code>r16</code> (or higher/lower) instead of <code>eax</code>, &hellip; and only literal values (called
<em>immediates</em>) are prefixed with a hash (<code>#</code>).</p>

<p>An important fact to remember is that the assembly syntax changes depending on the platform and compiler backend. Inline assembly in Rust on the ARM platform uses the ARM-syntax mentioned above.</p>

<h1 id="the-example-program">The example program</h1>

<p>The following program solves the simple problem of finding the midway point between two other points that will be stored in <code>r0</code> through <code>r3</code>. More precisely, given two vectors $\mathbf{A} := \begin{bmatrix} x_1 \\ y_1 \end{bmatrix}$ and $\mathbf{B} := \begin{bmatrix} x_2 \\ y_2 \end{bmatrix}$, we want to calculate the midpoint vector $\mathbf{M} := A + \frac{(\mathbf{B}-\mathbf{A})}{2} = \frac{\mathbf{A}+\mathbf{B}}{2}$.</p>

<p>Our initial algorithm is simple: First, we store all values in registers,</p>

<p>(Notation: $a \leftarrow b$ is the same as &ldquo;in $a$, store $b$&rdquo;)</p>

<ol start="1">
<li>$r_0 \leftarrow x_1$</li>
<li>$r_1 \leftarrow y_1$</li>
<li>$r_2 \leftarrow x_2$</li>
<li>$r_3 \leftarrow y_2$</li>
</ol>

<p>before adding the components together</p>

<ol start="5">
<li>$r_0 \leftarrow r_0 + r_2$</li>
<li>$r_1 \leftarrow r_1 + r_3$</li>
</ol>

<p>and diving each component by two</p>

<ol start="7">
<li>$r_0 \leftarrow \frac{r_0}{2}$</li>
<li>$r_1 \leftarrow \frac{r_1}{2}$</li>
</ol>

<p>This translates directly into assembly code:</p>

<pre><code class="language-armasm">;      we are looking for the midpoint-pixel between two points
;      A := (5, 6) and B := (15, 27)
;      expected result M: = (10, 16)

;      store A in r0 and r1
mov    r0, #5
mov    r1, #6

;      store B in r2 and r3
mov    r2, #15
mov    r3, #27

;      add both together
add    r0, r0, r2
add    r1, r1, r3

;      divide by two. since there is no division opcode on many ARMs,
;      we bitshift to the right
asr    r0, r0, #1
asr    r1, r1, #1

;      the end result of M := (10, 16) is now in r0, r1
</code></pre>

<p>The assembly code above will be used without comments further down. A fun way to try it out is using <a href="http://salmanarif.bitbucket.org/visual">Salman Arif&rsquo;s VisUAL</a> ARM emulator.</p>

<h1 id="running-rust-arm-code-on-x86">Running Rust ARM code on x86</h1>

<p>If you are not writing code on a <a href="https://www.raspberrypi.org/">Raspberry Pi</a> the chance that you are already working on an ARM machine are pretty slim. To keep things simple, we will write the example on an x86 machine using <a href="https://en.wikipedia.org/wiki/Cross_compiler">cross-compilation</a>. First, we use <a href="https://www.rustup.rs/">rustup</a> to install the necessary <code>arm-unknown-linux-gnueabihf</code>target:</p>

<pre><code class="language-sh">$ rustup target install arm-unknown-linux-gnueabihf
</code></pre>

<p>Now we can create a binary using Cargo with the following <code>main.rs</code></p>

<pre><code class="language-rust">#![feature(asm)]

fn main() {
    println!(&quot;Calculating...&quot;);

    unsafe {
        asm!(&quot;mov r0, #5
              mov r1, #6
              mov r2, #15
              mov r3, #27
              add r0, r0, r2
              add r1, r1, r3
              asr r0, r0, #1
              asr r1, r1, #1&quot;);
    }

    println!(&quot;Done&quot;);
}
</code></pre>

<p>and compile it (make sure you are on a nightly compiler):</p>

<pre><code class="language-sh">$ cargo build --target=arm-unknown-linux-gnueabihf
</code></pre>

<p>It should build okay.</p>

<h2 id="actually-running-it">Actually running it</h2>

<p>To run the foreign binary, we can take two approaches. First, we could copy the program to an ARM system like the Raspberry Pi or a virtual machine and execute it from there. Second, if we are lucky enough to be programming on a Linux-machine, there is a convenient way of running non-native binaries directly using <a href="https://wiki.debian.org/QemuUserEmulation">QEMU User Emulation</a>.</p>

<p>Assuming user mode emulation is installed, we can run our program like any other and have it tell us we did something wrong immediately:</p>

<pre><code class="language-text">$ cargo run --target=arm-unknown-linux-gnueabihf
    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/arm-unknown-linux-gnueabihf/debug/example-arm-asm`
Calculating...
qemu: uncaught target signal 11 (Segmentation fault) - core dumped
error: Process didn't exit successfully: `target/arm-unknown-linux-gnueabihf/debug/example-arm-asm` (signal: 11, SIGSEGV: invalid memory reference)
</code></pre>

<h1 id="the-asm-macro">The <code>asm!</code> macro</h1>

<p>Looking at the <code>asm!</code> macro, whose <a href="https://doc.rust-lang.org/book/inline-assembly.html">rather sparse documentation</a> prompted the writing of this article, we see that it has the following syntax:</p>

<pre><code class="language-rust">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>

<p>Any amount of trailing <code>:</code> is optional, so far our example code has just been using the <code>assembly template</code> part.</p>

<h2 id="clobbering">clobbering</h2>

<p>Now it is time to look at the reason why our program crashed. Disassembling our code using <code>arm-none-eabi-objdump -D target/arm-unknown-linux-gnueabihf/debug/example-arm-asm</code>, we get the following output (showing only relevant lines):</p>

<pre><code class="language-text">    ...
    3778:    e3a00005     mov    r0, #5
    377c:    e3a01006     mov    r1, #6
    3780:    e3a0200f     mov    r2, #15
    3784:    e3a0301b     mov    r3, #27
    3788:    e0800002     add    r0, r0, r2
    378c:    e0811003     add    r1, r1, r3
    3790:    e1a000c0     asr    r0, r0, #1
    3794:    e1a010c1     asr    r1, r1, #1
    3798:    e5901000     ldr    r1, [r0]
    ...
</code></pre>

<p>The first eight lines are the example code written above. Following the control flow, we see <code>ldr</code> loads data into the register <code>r1</code>, using an address stored <code>r0</code> &mdash; which was just overwritten with the result the algorithms output!</p>

<p>This is known as <em>clobbering</em> &mdash; by writing to registers without letting the compiler know about what we are doing, we have introduced undefined behaviour which will most likely result in a crash, as it did above.</p>

<p>To remedy, we can give a comma-separated list of registers that the assembly-code will use and the compiler will take care to structure all of its own calculations in a way that conflicts are avoided:</p>

<pre><code>asm!(&quot;mov r0, #5
      mov r1, #6
      mov r2, #15
      mov r3, #27
      add r0, r0, r2
      add r1, r1, r3
      asr r0, r0, #1
      asr r1, r1, #1&quot;
    :                          // no outputs yet
    :                          // no inputs yet
    :  &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;  // clobbers
    :                          // no options
);
</code></pre>

<p>Looking at the disassembly output again, we see that the contents of <code>r0</code> are saved on the stack before our code runs and restored after:</p>

<pre><code class="language-armasm">    3778:    e58d0008     str    r0, [sp, #8]
    ...
    379c:    e59d0008     ldr    r0, [sp, #8]

</code></pre>

<p>The example program now runs without crashing.</p>

<h2 id="output">output</h2>

<p>To make the code above even slightly useful, we will need to be able to collect its output values. For this, the <code>output</code> parameter of the <code>asm!</code> macro can be used. In inline assembly, <em>operand expressions</em> are used to tell the compiler which variables should hold the end result of a calculation.</p>

<p>Getting a good reference about these is hard &mdash; Rust passes these on to LLVM <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">(docs)</a> almost unchanged, which in turn bases its syntax on GCC <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">(docs)</a>, but there are some non-obvious differences.</p>

<p>Our simple example case is fortunately not complicated: We want to save the contents of registers <code>r0</code> and <code>r1</code> in two variables, which we will call <code>m_x</code> and <code>m_y</code>. For these, a type-annotated declaration must be introduced beforehand and the following <code>asm!</code> macro call changed:</p>

<pre><code class="language-rust">let m_x: u32;
let m_y: u32;

unsafe {
    asm!(&quot;mov r0, #5
          mov r1, #6
          mov r2, #15
          mov r3, #27
          add r0, r0, r2
          add r1, r1, r3
          asr r0, r0, #1
          asr r1, r1, #1&quot;
        :  &quot;={r0}&quot; (m_x), &quot;={r1} &quot;(m_y)  // outputs
        :                                // no inputs yet
        :  &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;        // clobbers
        :                                // no options
    );
}
</code></pre>

<p>The syntax for specifying outputs is as follows:</p>

<pre><code>'&quot;' constraint '&quot;' '(' variableName ')'
</code></pre>

<p>All output constraints start with a &ldquo;=&rdquo; (write) or &ldquo;+&rdquo; (read and write). <code>&quot;={r0}&quot;</code> restricts the placement to the register <code>r0</code>, it is wrapped in curly braces because otherwise single-letter values would be expected at the position.</p>

<p>The actual variable follows in parenthesis after the constraint. <code>m_x</code> and <code>m_y</code> are the obvious values here.</p>

<p>Note that this output declaration is not very clean or flexible, as it forces the compiler to place our outputs exactly inside <code>r0</code> and <code>r1</code>. A better way is to use template names and allow more flexible placement:</p>

<pre><code class="language-rust">let m_x: u32;
let m_y: u32;

unsafe {
    asm!(&quot;mov $0, #5
          mov $1, #6
          mov r2, #15
          mov r3, #27
          add $0, $0, r2
          add $1, $1, r3
          asr $0, $0, #1
          asr $1, $1, #1&quot;
        :  &quot;=r&quot;(m_x), &quot;=r&quot;(m_y)  // outputs
        :                        // no inputs yet
        :  &quot;r2&quot;, &quot;r3&quot;            // clobbers
        :                        // no options
    );
}

    println!(&quot;Result M: ({}, {})&quot;, m_x, m_y);
</code></pre>

<p>Instead of specifying a value, we replaced every occurence of <code>r0</code> with <code>$0</code>. The <code>$0</code> specifies that the first operand is to be used (the count starts at 0 with the first output constraint, with input constraints being counted last). The restriction <code>&quot;=r&quot;(m_x)</code> indicates that said first operand is an output operand that needs to be kept in a register (<code>&quot;=r&quot;</code>) and will be available in the variable <code>m_x</code>. The second operand is declared the same way.</p>

<p>The compiler can now choose which registers to use instead of <code>r0</code> and <code>r1</code>, which have disappeared from the assembly and the clobber list.</p>

<p>Running the program yields the expected result:</p>

<pre><code class="language-text">Result M: (10, 16)
</code></pre>

<h2 id="input">input</h2>

<p>Only getting outputs is still not sufficient, we want to be able to input things as well. Input operands work similar to output operands, sans the leading <code>=</code>:</p>

<pre><code class="language-rust">
let a_x = 5u32;
let a_y = 6u32;

let b_x = 15u32;
let b_y = 27u32;

// ...

asm!(&quot;mov $0, $2
      mov $1, $3
      mov r2, $4
      mov r3, $5
      add $0, $0, r2
      add $1, $1, r3
      asr $0, $0, #1
      asr $1, $1, #1
      &quot;
    :  &quot;=r&quot;(m_x), &quot;=r&quot;(m_y)                    // outputs
    :  &quot;r&quot;(a_x), &quot;r&quot;(a_y), &quot;r&quot;(b_x), &quot;r&quot;(b_y)  // inputs
    :  &quot;r2&quot;, &quot;r3&quot;                              // clobbers
    :                                          // no options
);
</code></pre>

<p>The code above will compile, but the result will be wrong:</p>

<pre><code>Result M: (5, 16)
</code></pre>

<p>This is because the program violated one of the <a href="http://llvm.org/docs/LangRef.html#output-constraints">requirements of LLVMs inline assembly</a>:</p>

<blockquote>
<p>Normally, it is expected that no output locations are written to by the assembly expression until all of the inputs have been read. As such, LLVM may assign the same register to an output and an input. If this is not safe (e.g. if the assembly contains two instructions, where the first writes to one output, and the second reads an input and writes to a second output), then the “&amp;” modifier must be used (e.g. “=&amp;r”) to specify that the output is an “early-clobber” output. Marking an output as “early-clobber” ensures that LLVM will not use the same register for any inputs (other than an input tied to this output).</p>
</blockquote>

<p>In other words, LLVM will freely use a register that we wanted to read input from as the output register in our assembly code. While occasionally hard to notice, this is easily fixed by reordering the template</p>

<pre><code class="language-rust">asm!(&quot;mov r2, $4
      mov r3, $5
      mov $0, $2
      mov $1, $3
      ...
      &quot;
// ...
</code></pre>

<p>We can optimize the code further though: Since we require all of our input variables to be in registers (via <code>&quot;r&quot;</code> constraints) already, it is possible to get rid of the initial <code>mov</code> instructions. We do need to mark them as &ldquo;early-clobber&rdquo; though, as we are using an output register at the same time as an input register (e.g. <code>$0</code> and <code>$2</code>):</p>

<pre><code class="language-rust">unsafe {
    asm!(&quot;add $0, $2, $4
          add $1, $3, $5
          asr $0, $0, #1
          asr $1, $1, #1
          &quot;
        :  &quot;=&amp;r&quot;(m_x), &quot;=&amp;r&quot;(m_y)                  // outputs
        :  &quot;r&quot;(a_x), &quot;r&quot;(a_y), &quot;r&quot;(b_x), &quot;r&quot;(b_y)  // inputs
        :                                          // clobbers
        :                                          // no options
    );
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Using a data strucuture and moving the inline assembly inside a function cleans up the code nicely:</p>

<pre><code class="language-rust">#![feature(asm)]

#[derive(Clone, Copy, Debug)]
struct Point {
    x: u32,
    y: u32,
}

/// Calculate the midpoint between two points `a` and `b`.
fn calc_midpoint(a: Point, b: Point) -&gt; Point {
    let m_x: u32;
    let m_y: u32;

    unsafe {
        asm!(&quot;add $0, $2, $4
              add $1, $3, $5
              asr $0, $0, #1
              asr $1, $1, #1
              &quot;
            :  &quot;=&amp;r&quot;(m_x), &quot;=&amp;r&quot;(m_y)                  // outputs
            :  &quot;r&quot;(a.x), &quot;r&quot;(a.y), &quot;r&quot;(b.x), &quot;r&quot;(b.y)  // inputs
            :                                          // clobbers
            :                                          // no options
        );
    }

    Point { x: m_x, y: m_y }
}

fn main() {
    let a = Point { x: 5, y: 6 };
    let b = Point { x: 15, y: 27 };

    let m = calc_midpoint(a, b);

    println!(&quot;Midpoint between A := {:?} and B := {:?} is:&quot;, a, b);
    println!(&quot;M = {:?}&quot;, m);
}
</code></pre>

<p>Inline assembly is tricky to get right and the documentation has a bit of a patchwork feel, especially if one is spoiled by the excellent material that is Rust&rsquo;s other documentation. Sometimes, though, there is no way around a few lines of inline assembly - a situation we will explore in another article.</p>

<p><em>Written by <a href="https://github.com/mbr">Marc Brinkmann</a>. Many thanks to Oliver Schneider and <a href="phil-opp.com">Philip Oppermann</a>.</em></p>

<!-- note: MathJax code should be moved to the theme at some point-->

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

    </div>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/embed-rs">The embed.rs Team</a> 2016</p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/rust.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/c.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


